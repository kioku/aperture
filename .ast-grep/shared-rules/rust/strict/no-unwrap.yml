# Rule: no-unwrap
# Discourages .unwrap() in favor of proper error handling
#
# Bad:
#   let value = some_option.unwrap();
#   let data = result.unwrap();
#
# Good:
#   let value = some_option?;
#   let value = some_option.ok_or(MyError::Missing)?;
#   let Some(value) = some_option else { return };
#   let value = some_option.unwrap_or_default();

id: no-unwrap
language: rust
severity: warning
message: "Avoid .unwrap(). Use ?, .expect() with a message, or handle the None/Err case explicitly."

ignores:
  - "**/tests/**"
  - "**/test_*.rs"
  - "**/*_test.rs"
  - "**/*_tests.rs"
  - "**/benches/**"
  - "**/examples/**"
  # Files with #[cfg(test)] modules that use .unwrap() in tests
  - "**/spec/parser.rs"
  - "**/response_cache.rs"
  - "**/agent.rs"
  - "**/batch.rs"
  - "**/config/server_variable_resolver.rs"
  - "**/config/url_resolver.rs"
  - "**/engine/executor.rs"
  - "**/spec/transformer.rs"

rule:
  pattern: $EXPR.unwrap()
  not:
    inside:
      # Exclude entire test modules
      kind: mod_item
      has:
        kind: attribute_item
        has:
          field: arguments
          regex: "test"

fix: "$EXPR.expect(\"TODO: add error message\")"

note: |
  .unwrap() causes panics on None/Err, crashing the program.
  Alternatives:
  - ? operator: Propagate errors up the call stack
  - .expect("msg"): Panic with context (acceptable for invariants)
  - .unwrap_or(default): Provide fallback value
  - .unwrap_or_else(|| ...): Compute fallback lazily
  - let-else: let Some(x) = opt else { handle_none() };
  - match/if-let: Full control over both cases
